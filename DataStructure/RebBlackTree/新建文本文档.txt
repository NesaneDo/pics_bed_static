package com.datastructure.test;

/**
 * 1. 创建 RBTree，定义颜色
 * 
 * 2. 创建 RBNode
 * 
 * 3. 辅助方法定义：parentOf(node); isRed(node); isBlack(node); setRed(node);
 * setBlack(node); inOrderPrint()
 * 
 * 4. 左旋方法定义：leftRotate(node)
 * 
 * 5.右旋方法定义：rightRotate(node)
 * 
 * 6. 公开插入接口方法定义：insert(K key,V value)
 * 
 * 7.内部插入接口方法定义：insert(RBNode node)
 * 
 * 8. 修正插入导致红黑树失衡的方法定义：insertFixUp(RBNode node)
 * 
 * 9. 测试红黑树正确性
 * 
 * @author Rondo
 *
 */
public class RBTree<K extends Comparable<K>, V> {
	private static final boolean RED = true;
	private static final boolean BLACK = true;

	private RBNode root;

	public RBTree(RBNode root) {
		this.root=root;
	}
	/**
	 * 获取当前节点的父节点
	 * 
	 * @param node
	 * @return
	 */
	private RBNode parentOf(RBNode node) {
		if (node != null) {
			return node.parent;
		}
		return null;
	}

	/**
	 * 节点是否为红色
	 * 
	 * @param node
	 * @return
	 */
	private boolean isRed(RBNode node) {
		if (node != null) {
			return node.color == RED;
		}
		return false;
	}

	/**
	 * 节点是否为黑色
	 * 
	 * @param node
	 * @return
	 */
	private boolean isBlack(RBNode node) {
		if (node != null) {
			return node.color == BLACK;
		}
		return false;
	}

	/**
	 * 设置节点为红色
	 * 
	 * @param node
	 */
	private void setRed(RBNode node) {
		if (node != null) {
			node.color = RED;
		}
	}
	/**
	 * 设置节点为黑色
	 * 
	 * @param node
	 */
	private void setBlack(RBNode node) {
		if (node != null) {
			node.color = BLACK;
		}
	}

	public void inOrderPrint() {
		inOrderPrint(this.root);
	}

	/**
	 * 中序打印
	 * 
	 * @param node
	 */
	private void inOrderPrint(RBNode node) {
		if (node != null) {
			inOrderPrint(node.left);
			System.out.println("key:" + node.key + " value:" + node.value);
			inOrderPrint(node.right);
		}
	}
	/**
	 * 左 旋 示意图（左旋 x 节点）
	 * 
	 * 			P				P
	 * 			|				|
	 * 			x				y
	 * 		   / \    ===>     / \
	 * 		  lx  y			  x   ry
	 * 			 / \		 / \
	 * 			ly  ry		lx  ly
	 * 
	 * 1. 将 x 的右子节点指向 y 的左子节点（ly）,将 y 的左子节点的父节点更新为 x
	 * 
	 * 2. 当 x 的父节点（不为空时）， 更新 y 的父节点为 x 的父节点，并将 x 的父节点指向子树（当前 x 的子树位置）指定为 y
	 * 
	 * 3. 将 x 的父节点更新为 y，将 y 的左子节点更新为 x
	 * 
	 * @param node
	 */
	private void leftRotate(RBNode x) {
		RBNode y = x.right;
		// 1. 将 x 的右子节点指向 y 的左子节点（ly）,将 y 的左子节点的父节点更新为 x
		x.right = y.left;
		if (y.left != null) { 
			y.left.parent = x;
		}
		// 2. 当 x 的父节点（不为空时）， 更新 y 的父节点为 x 的父节点，并将 x 的父节点指向子树（当前 x 的子树位置）指定为 y
		if (x.parent != null) {
			y.parent = x.parent;
			if (x == x.parent.left) { // ???
				x.parent.left = y;
			} else {
				x.parent.right = y;
			}
		}else { // x 为根节点
			this.root=y;
		}
		// 3. 将 x 的父节点更新为 y，将 y 的左子节点更新为 x
		x.parent = y;
		y.left = x;
	}
	/**
	 * 左 旋 示意图（右旋 y 节点）
	 * 
	 * 			P				P
	 * 			|				|
	 * 			y				x
	 * 		   / \    ===>     / \
	 * 		  x   ry		  lx  y
	 * 		 / \		 		 / \
	 * 		lx  ly				ly  ry
	 * 
	 * 1. 将 y 的左子节点指向 x 的右子节点（ly）,将 x 的右子节点的父节点更新为 y
	 * 
	 * 2. 当 y 的父节点（不为空时）， 更新 x 的父节点为 y 的父节点，更新 y 的父节点指向子树（y 当前的位置）指定为 x
	 * 
	 * 3. 将 y 的父节点更新为 x，将 x 的右子节点更新为 y
	 * 
	 * @param node
	 */
	private void rightRotate(RBNode y) {
		RBNode x=y.left;
		// 1. 将 y 的左子节点指向 x 的右子节点（ly）,将 x 的右子节点的父节点更新为 y
		y.left=x.right;
		if (x.right != null) {
			x.right.parent=y;
		}
		
		// 2. 当 y 的父节点（不为空时）， 更新 x 的父节点为 y 的父节点，更新 y 的父节点指向子树（y 当前的位置）指定为 x
		if (y.parent != null) {
			x.parent=y.parent;
			
			if (y == y.parent.left) {
				y.parent.left=x;
			}
		}else {
			this.root=x;
		}
		
		// 3. 将 y 的父节点更新为 x，将 x 的右子节点更新为 y
		y.parent=x;
		x.right=y;
	}
	
	public void insert(K key, V value) {
		RBNode node=new RBNode();
		node.setKey(key);
		node.setValue(value);
		// 新节点一定是红色
		node.setColor(RED);
		insert(node);
	}
	
	private void insert(RBNode node) {
		// 1. 查找当前 node 的父节点
		RBNode parent=null;
		RBNode x=this.root;
		while(x != null) {
			parent=x;
			// 如果 cmp > 0 ：说明 node.key > x.key 需要到 x 的右子节点查找
			// 如果 cmp == 0 ：说明 node.key == x.key 需要进行替换操作
			// 如果 cmp < 0 ：说明 node.key < x.key 需要到 x 的左子节点查找
			int cmp = node.key.compareTo(x.key);
			if (cmp>0) {
				x=x.right;
			}else if (cmp == 0) {
				x.setValue(node.getValue());
				return;
			}else {
				x=x.left;
			}
		}
		node.parent=parent;
		
		if (parent!=null) {
			// 判断 node 与 parent 的 key 
			int cmp = node.key.compareTo(parent.key);
			if (cmp > 0) { // 当前 node.key > parent.key，需要把 node 连到 parent 的右子节点上
				parent.right=node;
			}else {// 当前 node.key < parent.key，需要把 node 连到 parent 的左子节点上
				parent.left=node;
			}
		}else {
			this.root=node;
		}
		
		// 需要自平衡
		insertFixUp(node);
	}

	/**
	 * 插入新节点后的自平衡
	 * 		|---情景1：红黑树为空，直接将根节点变为黑色
	 * 		|---情景2：插入节点的 key 已存在，直接更新 key 值即可
	 * 		|---情景3：插入节点的父节点为黑色，直接插入即可，需要自平衡
	 * 		|---情景4：插入节点的父节点为红色
	 * 			|---情景4.1：叔叔节点存在且为红色，将 P（父节点） 和 U（叔叔节点）变为黑色，
	 * 					将 PP（爷爷节点） 变为红色并设置为当前节点，然后进行下一轮处理
	 * 			|---情景4.2：叔叔节点不存在或为黑色，父节点为爷爷节点的左子树
	 * 				|---情景4.2.1：插入节点为父节点的左子节点（LL 双红），将爸爸和叔叔变为黑色，将爷爷变为红色，再以爷爷节点右旋处理
	 * 				|---情景4.2.2：插入节点为父节点的右子节点（LR 双红），以爸爸节点进行一次左旋处理，然后变为（4.2.1）的情况
	 * 			|---情景4.3：叔叔节点不存在或为黑色，父节点为爷爷节点的右子树
	 * 				|---情景4.3.1：插入节点为父节点的右子节点（RR 双红），将爸爸节点变为黑色，将爷爷变为红色，再以爷爷节点左旋处理
	 * 				|---情景4.3.2：插入节点为父节点的左子节点（RL 双红），以爸爸节点进行一次右旋处理，然后变为（4.3.1）的情况
	 */
	private void insertFixUp(RBNode node) {
		this.root.setColor(BLACK);
		
		RBNode parent=parentOf(node);
		RBNode gparent=parentOf(parent);
		// 情景4
		if (parent!=null && isRed(parent)) {
			// 如果父节点是红色，则一定存在爷爷节点
			RBNode uncle=null;
			if(parent==gparent.left) { // 父节点为爷爷节点的左子节点
				uncle=gparent.right;
				
				// 情景4.1：叔叔节点存在且为红色
				if (uncle !=null && isRed(uncle)) {
					setBlack(parent);
					setBlack(uncle);
					setRed(gparent);
					insertFixUp(gparent);
					return;
				}
				
				// 情景4.2: 叔叔节点不存在或为黑色
				if (uncle == null || isBlack(uncle)) {
					// 情景4.2.1：插入节点为父节点的左子节点（LL 双红），将爸爸变为黑色，将爷爷变为红色，再以爷爷节点右旋处理
					if (node == parent.left) {
						setBlack(parent);
						setRed(gparent);
						rightRotate(gparent);
						return;
					}
					// 情景4.2.2：插入节点为父节点的右子节点（LR 双红），以爸爸节点进行一次左旋处理，然后变为（4.2.1）的情况，进行下一轮处理
					if (node == parent.right) {
						leftRotate(parent);
						insertFixUp(parent);
						return;
					}
				}
				
			}else { // 父节点为爷爷节点的右子节点
				uncle=gparent.left;
				// 情景4.1：叔叔节点存在且为红色
				if (uncle !=null && isRed(uncle)) {
					setBlack(parent);
					setBlack(uncle);
					setRed(gparent);
					insertFixUp(gparent);
					return;
				}
				
				// 情景4.3: 叔叔节点不存在或为黑色
				if (uncle == null || isBlack(uncle)) {
					// 情景4.3.1：插入节点为父节点的右子节点（RR 双红），将爸爸节点变为黑色，将爷爷变为红色，再以爷爷节点左旋处理
					if (node == parent.left) {
						setBlack(parent);
						setRed(gparent);
						leftRotate(gparent);
						return;
					}
					// 情景4.3.2：插入节点为父节点的左子节点（RL 双红），以爸爸节点进行一次右旋处理，然后变为（4.3.1）的情况，进行下一轮处理
					if (node == parent.right) {
						rightRotate(parent);
						insertFixUp(parent);
						return;
					}
				}
			}
		}
	}

	/**
	 * 节点类
	 * 
	 * @author Rondo
	 *
	 * @param <K>
	 * @param <V>
	 */
	static class RBNode<K extends Comparable<K>, V> {
		private RBNode parent;
		private RBNode left;
		private RBNode right;
		private boolean color;
		private K key;
		private V value;

		public RBNode() {
		}

		public RBNode(RBNode parent, RBNode left, RBNode right, boolean color,
				K key, V value) {
			super();
			this.parent = parent;
			this.left = left;
			this.right = right;
			this.color = color;
			this.key = key;
			this.value = value;
		}
		public RBNode getParent() {
			return parent;
		}
		public void setParent(RBNode parent) {
			this.parent = parent;
		}
		public RBNode getLeft() {
			return left;
		}
		public void setLeft(RBNode left) {
			this.left = left;
		}
		public RBNode getRight() {
			return right;
		}
		public void setRight(RBNode right) {
			this.right = right;
		}
		public boolean isColor() {
			return color;
		}
		public void setColor(boolean color) {
			this.color = color;
		}
		public K getKey() {
			return key;
		}
		public void setKey(K key) {
			this.key = key;
		}
		public V getValue() {
			return value;
		}
		public void setValue(V value) {
			this.value = value;
		}
	}
}
